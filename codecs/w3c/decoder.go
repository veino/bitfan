//go:generate bitfanDoc -codec w3c
// Parses comma-separated value data into individual fields
package w3ccodec

import (
	"encoding/csv"
	"fmt"
	"io"
	"strings"

	"github.com/mitchellh/mapstructure"
	"github.com/vjeantet/bitfan/codecs/lib"
)

type decoder struct {
	more        bool
	r           *csv.Reader
	columnnames []string
	options     decoderOptions
	log         lib.Logger
}

// Parses comma-separated value data into individual fields
type decoderOptions struct {

	// Define the column separator value. If this is not specified, the default is a whitespace. Optional
	// @Default " "
	Separator string `mapstructure:"separator"`

	// Define whether column names should autogenerated or not. Defaults to true.
	// If set to false, columns not having a header specified will not be parsed.
	// @Default true
	AutogenerateColumnNames bool `mapstructure:"autogenerate_column_names"`

	// Define the character used to quote fields. If this is not specified the default is a double quote ". Optional.
	// @Default "\""
	QuoteChar string `mapstructure:"quote_char"`

	// Define a list of column names
	//
	// If columns is not configured, or there are not enough columns specified,
	// the default column names are "column1", "column2", etc.
	//
	// In the case that there are more columns in the data than specified in this column
	// list, extra columns will be auto-numbered:
	// (e.g. "user_defined_1", "user_defined_2", "column3", "column4", etc.)
	Columns []string `mapstructure:"columns"`

	// Define the comment character.
	// Lines beginning with the Comment character without preceding whitespace are ignored.
	// @Default "#"
	Comment string `mapstructure:"comment"`
}

func NewDecoder(r io.Reader) *decoder {
	d := &decoder{
		r:    csv.NewReader(r),
		more: true,
		options: decoderOptions{
			Separator:               " ",
			AutogenerateColumnNames: true,
			QuoteChar:               "\"",
			Comment:                 "#",
		},
	}

	return d
}
func (d *decoder) SetOptions(conf map[string]interface{}, logger lib.Logger, cwl string) error {
	d.log = logger

	if err := mapstructure.Decode(conf, &d.options); err != nil {
		return err
	}

	d.r.Comma = []rune(d.options.Separator)[0]

	if len(d.options.Columns) > 0 {
		d.columnnames = d.options.Columns
	}

	return nil
}

func (d *decoder) Decode(data *interface{}) error {
	record, err := d.r.Read()

	if err == io.EOF {
		d.more = false
		return err
	}

	*data = map[string]interface{}{}

	if strings.HasPrefix(record[0], d.options.Comment) {
		if d.options.AutogenerateColumnNames && strings.HasPrefix(record[0], d.options.Comment+"Fields:") {
			sourceString := strings.Trim(strings.Replace(strings.Join(record, d.options.Separator), d.options.Comment+"Fields: ", "", 1), " ")
			d.columnnames = strings.Split(sourceString, " ")
			return d.Decode(data)
		}
		return d.Decode(data)
	}

	for i := range record {
		var column string
		if i >= len(d.columnnames) {
			column = fmt.Sprintf("column%d", i+1)
		} else {
			column = d.columnnames[i]
		}
		(*data).(map[string]interface{})[column] = record[i]
	}

	return nil
}

func (d *decoder) More() bool {
	return d.more
}
